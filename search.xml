<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>变分自动编码器</title>
      <link href="/2018/11/20/VAE/"/>
      <url>/2018/11/20/VAE/</url>
      
        <content type="html"><![CDATA[<h1 id="Autoencoder-自动编码器"><a href="#Autoencoder-自动编码器" class="headerlink" title="Autoencoder 自动编码器"></a>Autoencoder 自动编码器</h1><h2 id="降维模型"><a href="#降维模型" class="headerlink" title="降维模型"></a>降维模型</h2><ul><li>encoder：得到一张图片，将图片的编码向量存起来</li><li>decoder：使用这些编码向量来重构我们的图像<a id="more"></a></li></ul><hr><h1 id="Variational-Autoencoder-变分自动编码器"><a href="#Variational-Autoencoder-变分自动编码器" class="headerlink" title="Variational Autoencoder 变分自动编码器"></a>Variational Autoencoder 变分自动编码器</h1><h2 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h2><ul><li>encoder:对编码器添加约束，强迫其产生服从单位高斯分布的潜在变量</li><li>decoder:既可以由图片经过encoder编码，也可以从单位高斯分布采样产生</li></ul><p>损失函数：图片的重构误差 + 潜在变量分布于高斯分布之间的差异<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">generation_loss = mean(square(generated_image - real_image))</span><br><span class="line">latent_loss = KL-Divergence(latent_variable, unit_gaussian)</span><br><span class="line">loss = generation_loss + latent_loss</span><br></pre></td></tr></table></figure></p><p>定义kd_loss<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">latent_loss = 0.5 * tf.reduce_sum(tf.square(z_mean) + tf.square(z_stddev) - tf.log(tf.square(z_stddev))-1, 1)</span><br></pre></td></tr></table></figure></p><p>生成图片<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samples = tf.random_normal([batch_size, n_z], 0, 1, dtype=tf.float32)</span><br><span class="line">sampled_z = z_mean + (z_stddev * samples)</span><br></pre></td></tr></table></figure></p><hr><h1 id="相关"><a href="#相关" class="headerlink" title="相关"></a>相关</h1><ul><li>PCA 降维模型</li><li>概率PCA 生成模型</li></ul><hr><h1 id="LDA-vs-PCA"><a href="#LDA-vs-PCA" class="headerlink" title="LDA vs PCA"></a>LDA vs PCA</h1><ul><li>LDA选择分类性能最好的投影方向，PCA选择样本点投影具有最大方差的方向</li></ul><hr><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><a href="http://blog.otoro.net/2016/04/01/generating-large-images-from-latent-vectors/" target="_blank" rel="noopener">结合VAE和GAN</a> <a href="https://jmetzen.github.io/2015-11-27/vae.html" target="_blank" rel="noopener">代码</a></li><li><a href="https://www.cnblogs.com/huangshiyu13/p/6209016.html" target="_blank" rel="noopener">VAE(Variational Autoencoder)的原理</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIwMTc4ODE0Mw==&amp;mid=2247490939&amp;idx=1&amp;sn=7799ad3e2e864690c48c10fb3b919f37&amp;chksm=96e9c2fba19e4bed434f875d65a7696b0a49896b719272926a94b182deb5d3752b5f07ac4332&amp;scene=0#rd" target="_blank" rel="noopener">漫谈概率 PCA 和变分自编码器</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> variable autoencoder </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>House Robbers</title>
      <link href="/2018/10/31/House_Robber_problems/"/>
      <url>/2018/10/31/House_Robber_problems/</url>
      
        <content type="html"><![CDATA[<h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><h2 id="LeetCode198-House-Robber"><a href="#LeetCode198-House-Robber" class="headerlink" title="[LeetCode198.House Robber]"></a>[LeetCode198.House Robber]</h2><p>今晚，你是一个抢劫犯，去抢劫一条街上的居民。抢劫两个相邻的用户你将会触发报警装置，怎么安排抢劫策略才能抢到最多的钱。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br></pre></td></tr></table></figure></p><h3 id="1-动态规划："><a href="#1-动态规划：" class="headerlink" title="1. 动态规划："></a>1. 动态规划：</h3><p>dp[i]表示到第i家可以获利最多。（i从0开始，dp数组共有i+1个数）<br>假设nums为{3, 2, 1, 5}，接下来我们推导dp数组的表示。<br>首先dp[0]=0,dp[1]=3没啥疑问，再看dp[2]是多少呢，由于3比2大，所以我们抢第一个房子的3，当前房子的2不抢，所以dp[2]=3，再来看dp[3]，由于不能抢相邻的，所以我们可以用dp[i-2]的值加上当前的房间值nums[i-1](nums[2]即为第3个房间的值)，和当前房间的前面一个dp值（dp[i-1]）比较，取较大值当做当前dp值。<br>则我们写出递推公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i-1], dp[i-2] + nums[i-1])</span><br></pre></td></tr></table></figure></p><p>由此看出我们需要初始化dp[0]和dp[1]，其中dp[0]为0, dp[1]为max(0, num[0])=num[0]。</p><p>Solution:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span> , <span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++)</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-单双计数"><a href="#2-单双计数" class="headerlink" title="2.单双计数"></a>2.单双计数</h3><p>分别维护两个变量count_one和count_two，然后按照奇偶来分别更新他们，这样可以保证组成最大和的数字不相邻。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count_one = <span class="number">0</span></span><br><span class="line">        count_two = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                count_two = max(count_two + nums[i], count_one)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_one = max(count_one + nums[i], count_two)</span><br><span class="line">        <span class="keyword">return</span> max(count_one, count_two)</span><br></pre></td></tr></table></figure></p><h2 id="LeetCode213-House-Robber-II"><a href="#LeetCode213-House-Robber-II" class="headerlink" title="[LeetCode213.House_Robber_II]"></a>[LeetCode213.House_Robber_II]</h2><p>现在房子排成了一个圆圈。如果抢了第一家，就不能抢最后一家，因为首尾相连了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [2,3,2]</span><br><span class="line">Output: 3</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>第一家和最后一家只能抢其中的一家，或者都不抢。我们这里变通一下，如果我们把第一家和最后一家分别去掉，各算一遍能抢的最大值，然后比较两个值取其中较大的一个即为所求。那我们只需参考之前的 House Robber 打家劫舍中的解题方法，然后调用两边取较大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = len(nums)</span><br><span class="line">        <span class="keyword">if</span> length == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> length == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> max(self.rob_no_circle(nums[:<span class="number">-1</span>]), self.rob_no_circle(nums[<span class="number">1</span>:]))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob_no_circle</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        count_one = <span class="number">0</span></span><br><span class="line">        count_two = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                count_two = max(count_two + nums[i], count_one)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count_one = max(count_one + nums[i], count_two)</span><br><span class="line">        <span class="keyword">return</span> max(count_one, count_two)</span><br></pre></td></tr></table></figure><h2 id="LeetCode337-House-Robber-III"><a href="#LeetCode337-House-Robber-III" class="headerlink" title="[LeetCode337.House_Robber_III]"></a>[LeetCode337.House_Robber_III]</h2><p>这个小偷又偷出新花样了，沿着二叉树开始偷.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [3,2,3,null,3,null,1]</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   2   3</span><br><span class="line">    \   \ </span><br><span class="line">     3   1</span><br><span class="line">Output: 7 (3 + 3 + 1 = 7)</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [3,4,5,1,3,null,1]</span><br><span class="line">     3</span><br><span class="line">    / \</span><br><span class="line">   4   5</span><br><span class="line">  / \   \ </span><br><span class="line"> 1   3   1</span><br><span class="line">Output: 9 (4 + 5 = 9)</span><br></pre></td></tr></table></figure></p><p>题目中给的例子看似好像是要每隔一个偷一次，但实际上不一定只隔一个,比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      4</span><br><span class="line">     / </span><br><span class="line">    1  </span><br><span class="line">   /   </span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p>如果隔一个偷，那么是4+2=6，其实最优解应为4+3=7，隔了两个。</p><h3 id="定义子函数算出是否抢当前节点"><a href="#定义子函数算出是否抢当前节点" class="headerlink" title="定义子函数算出是否抢当前节点"></a>定义子函数算出是否抢当前节点</h3><p>返回一个大小为2的一维数组tmp_result，其中tmp_result[0]表示不包含当前节点值的最大值，tmp_result[1]表示包含当前值的最大值，那么我们在遍历某个节点时，首先对其左右子节点调用递归函数，分别得到包含与不包含左子节点值的最大值，和包含于不包含右子节点值的最大值，那么当前节点的tmp_result[0]就是左子节点两种情况的较大值加上右子节点两种情况的较大值，tmp_results[1]就是不包含左子节点值的最大值加上不包含右子节点值的最大值，和当前节点值之和，返回即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def rob(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not root:</span><br><span class="line">            return 0</span><br><span class="line">        result = max(self.subRob(root))</span><br><span class="line">        return result</span><br><span class="line">    </span><br><span class="line">    def subRob(self, root):</span><br><span class="line">        left_val = [0, 0]</span><br><span class="line">        right_val = [0, 0]</span><br><span class="line">        tmp_result = [0, 0]</span><br><span class="line">        if not root:</span><br><span class="line">            return [0, 0]</span><br><span class="line">        if root.left:</span><br><span class="line">            left_val = self.subRob(root.left)</span><br><span class="line">        if root.right:</span><br><span class="line">            right_val = self.subRob(root.right)        </span><br><span class="line">        # not rob root</span><br><span class="line">        tmp_result[0] = max(left_val[0], left_val[1]) + max(right_val[0], right_val[1])</span><br><span class="line">        # rob root</span><br><span class="line">        tmp_result[1] = root.val + left_val[0] + right_val[0]</span><br><span class="line">        return tmp_result</span><br></pre></td></tr></table></figure></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="http://www.cnblogs.com/grandyang/p/4383632.html" target="_blank" rel="noopener">LeetCode House Robber 打家劫舍</a></li><li><a href="http://www.cnblogs.com/grandyang/p/4518674.html" target="_blank" rel="noopener">LeetCode House Robber II 打家劫舍之二</a></li><li><a href="https://www.cnblogs.com/grandyang/p/5275096.html" target="_blank" rel="noopener">LeetCode House Robber III 打家劫舍之三</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Coin Change</title>
      <link href="/2018/10/31/Coin-Change/"/>
      <url>/2018/10/31/Coin-Change/</url>
      
        <content type="html"><![CDATA[<h5 id="Coin-change"><a href="#Coin-change" class="headerlink" title="Coin change"></a>Coin change</h5><p>硬币找零问题：给定一个数组coins表示零钱的面值，然后给出手头钱的总数amount，问最少可以用多少枚硬币找零。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"> Input:coins=[1, 2, 5], amount = 11</span><br><span class="line"> Output：3</span><br><span class="line"> Explanation: 11 = 5 + 5 + 1</span><br><span class="line"> </span><br><span class="line">Example 2:</span><br><span class="line"> Input:coins=[1, 2, 5], amount = 3</span><br><span class="line"> Output:-1</span><br></pre></td></tr></table></figure></p><h5 id="1-BFS-广度优先搜索"><a href="#1-BFS-广度优先搜索" class="headerlink" title="1.BFS(广度优先搜索)"></a>1.BFS(广度优先搜索)</h5><p>以当前值amount为起点，相邻的每一个节点为amount-coin(coin in coins, amount - coin),找出能找零的最小层即可，找不到返回-1.（运行超时）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def coinChange(self, coins, amount):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type coins: List[int]</span><br><span class="line">        :type amount: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        count = 0</span><br><span class="line">        if not coins:</span><br><span class="line">            return -1</span><br><span class="line">        if not amount:</span><br><span class="line">            return 0</span><br><span class="line">        if amount &lt; coins[0]:</span><br><span class="line">            return -1</span><br><span class="line">        q_store = [amount]</span><br><span class="line">        while q_store:</span><br><span class="line">            count += 1</span><br><span class="line">            q_list = q_store</span><br><span class="line">            q_store = []</span><br><span class="line">            for q in q_list:</span><br><span class="line">                for coin in coins:</span><br><span class="line">                    if q &gt; coin:</span><br><span class="line">                        q_store.append(q - coin)</span><br><span class="line">                    elif q &lt; coin:</span><br><span class="line">                        break</span><br><span class="line">                    else:</span><br><span class="line">                        return count</span><br><span class="line">            return -1</span><br></pre></td></tr></table></figure></p><h5 id="2-DFS-深度优先搜索-剪枝"><a href="#2-DFS-深度优先搜索-剪枝" class="headerlink" title="2.DFS(深度优先搜索) + 剪枝"></a>2.DFS(深度优先搜索) + 剪枝</h5><p>从最大的硬币开始选择，尽可能地多用大面值的硬币。找到一个方案保存最小的层数ans,后面大于ans的不用再搜索。（python3测试超时）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">def __init__(self):</span><br><span class="line">self.ans = float(&apos;inf&apos;)</span><br><span class="line"></span><br><span class="line">def coinChange(self, coins, amount):</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">:type coins: List[int]</span><br><span class="line">:type amount: int</span><br><span class="line">:rtype: int</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">if not coins:</span><br><span class="line">return -1</span><br><span class="line">if not amount:</span><br><span class="line">return 0</span><br><span class="line">coins.sort(reverse=True)</span><br><span class="line"></span><br><span class="line">def coin_change(coins, s, amount, count):</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">深度优先搜索树</span><br><span class="line">:param coins:硬币的组成[5. 2. 1]</span><br><span class="line">:param s: 当前遍历的层数[0, 1, 2]</span><br><span class="line">:param amount: 剩余硬币的数值</span><br><span class="line">:param count: 当前已经使用硬币的数量</span><br><span class="line">:return: 返回最后的最少使用硬币的数量</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">coin = coins[s]</span><br><span class="line">if s == len(coins) - 1:</span><br><span class="line"># 最后一层</span><br><span class="line">if (amount % coin == 0) and (self.ans &gt; (count + amount // coin)):</span><br><span class="line">self.ans = count + amount // coin</span><br><span class="line">else:</span><br><span class="line">for k in range(amount // coin, -1, -1):</span><br><span class="line">if count + k &lt; self.ans:</span><br><span class="line">coin_change(coins, s + 1, amount - k * coin, count + k)</span><br><span class="line"></span><br><span class="line">coin_change(coins, 0, amount, 0)</span><br><span class="line">return self.ans if self.ans != float(&apos;inf&apos;) else -1</span><br></pre></td></tr></table></figure></p><h6 id="3-DP算法"><a href="#3-DP算法" class="headerlink" title="3.DP算法"></a>3.DP算法</h6><p>1）使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(dp[i], dp[i - k * coin] + k)</span><br></pre></td></tr></table></figure></p><p>来更新dp[i],即当前值用 min(当前值，k枚 + 当前值之前k*coin位置的值) 更新。<br>这种方法的时间复杂度为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n * amount^2</span><br></pre></td></tr></table></figure></p><p>（测试超时）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def coinChange(self, coins, amount):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type coins: List[int]</span><br><span class="line">        :type amount: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dp = [amount + 1 for _ in range(amount + 1)]</span><br><span class="line">        dp[0] = 0</span><br><span class="line">        for coin in coins:</span><br><span class="line">            for i in range(amount - coin, -1, -1):</span><br><span class="line">                if dp[i] != amount + 1:</span><br><span class="line">                    range_k = (amount - i) // coin + 1</span><br><span class="line">                    for k in range(range_k):</span><br><span class="line">                        dp[i + k * coin] = min(dp[i] + k, dp[i + k * coin])</span><br><span class="line">        return dp[amount] if dp[amount] &lt; amount + 1 else -1</span><br></pre></td></tr></table></figure></p><p> 2）使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(dp[i], dp[i - coin] + 1)</span><br></pre></td></tr></table></figure></p><p>来更新。每次考虑当前增加使用这枚硬币的情况，保存下最小值。（测试通过）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def coinChange(self, coins, amount):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type coins: List[int]</span><br><span class="line">        :type amount: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        dp = [amount + 1 for _ in range(amount + 1)]</span><br><span class="line">        dp[0] = 0</span><br><span class="line">        for coin in coins:</span><br><span class="line">            for i in range(coin, amount + 1):</span><br><span class="line">                dp[i] = min(dp[i], dp[i - coin] + 1)</span><br><span class="line">        return dp[amount] if dp[amount] &lt; amount + 1 else -1</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>upload-image</title>
      <link href="/2018/10/30/upload-image/"/>
      <url>/2018/10/30/upload-image/</url>
      
        <content type="html"><![CDATA[<p>图片上传测试<br><img src="/2018/10/30/upload-image/0.jpg" alt="images in here"></p>]]></content>
      
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Hexo搭建本地博客并git上传</title>
      <link href="/2018/10/30/hexo-use/"/>
      <url>/2018/10/30/hexo-use/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo本地使用"><a href="#Hexo本地使用" class="headerlink" title="Hexo本地使用"></a>Hexo本地使用</h1><h2 id="从零开始安装Hexo"><a href="#从零开始安装Hexo" class="headerlink" title="从零开始安装Hexo"></a>从零开始安装Hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-clo // 一键搞定</span><br></pre></td></tr></table></figure><a id="more"></a><p>建立一个文件夹Hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo i blog // init的缩写 blog是项目名  </span><br><span class="line">cd blog // 切到站点根目录</span><br><span class="line">hexo g // hexo generate</span><br><span class="line">hexo s // hexo server</span><br></pre></td></tr></table></figure><p>打开localhost:4000查看  </p><h2 id="换一个主题"><a href="#换一个主题" class="headerlink" title="换一个主题"></a>换一个主题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>打开站点配置文件将主题改为：next<br>终端输入：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean //清除缓冲</span><br><span class="line">hexo g // 重新生成代码</span><br><span class="line">hexo s // 部署到本地</span><br></pre></td></tr></table></figure><h1 id="本地博客上传到github"><a href="#本地博客上传到github" class="headerlink" title="本地博客上传到github"></a>本地博客上传到github</h1><h2 id="使用github建立一个新的项目"><a href="#使用github建立一个新的项目" class="headerlink" title="使用github建立一个新的项目"></a>使用github建立一个新的项目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New repository // 命名为username.github.io</span><br></pre></td></tr></table></figure><h2 id="创建pages"><a href="#创建pages" class="headerlink" title="创建pages"></a>创建pages</h2><h2 id="选择主题"><a href="#选择主题" class="headerlink" title="选择主题"></a>选择主题</h2><h1 id="部署hexo站点到github上"><a href="#部署hexo站点到github上" class="headerlink" title="部署hexo站点到github上"></a>部署hexo站点到github上</h1><h2 id="修改hexo站点的配置文件"><a href="#修改hexo站点的配置文件" class="headerlink" title="修改hexo站点的配置文件"></a>修改hexo站点的配置文件</h2><p>配置文件冒号后面有半角空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:  </span><br><span class="line">  type: git  </span><br><span class="line">     repository: https://github.com/username/username.github.io</span><br><span class="line">     branch: master</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  </span><br><span class="line">hexo g  </span><br><span class="line">hexo d //hexo deploy</span><br></pre></td></tr></table></figure><h1 id="发布新的博客"><a href="#发布新的博客" class="headerlink" title="发布新的博客"></a>发布新的博客</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &apos;new_post&apos; // hexo n &apos;new_post&apos;</span><br></pre></td></tr></table></figure><p>会生成新的new_post.md在source/_posts下 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><blockquote><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a> 更多hexo主题<br><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">https://www.zhihu.com/question/24422335</a> 知乎上的hexo主题</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/30/hello-world/"/>
      <url>/2018/10/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>About Me</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul><li>手机：18810899275</li><li>Email：<a href="mailto:2957308424@qq.com" target="_blank" rel="noopener">2957308424@qq.com</a></li><li>微信号：lazy960118</li></ul><h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul><li>李哲 / 男 /1996</li><li>硕士 / 北京邮电大电子工程学院 / 在读</li><li>技术博客：<a href="https://lizhe960118.github.io">https://lizhe960118.github.io</a></li><li>个人专栏：</li><li><p>Github：<a href="http://github.com/lizhe960118" target="_blank" rel="noopener">http://github.com/lizhe960118</a></p></li><li><p>期望职位：开发岗位实习，算法岗位实习</p></li><li>期望城市：北京</li></ul><h2 id="技术文章"><a href="#技术文章" class="headerlink" title="技术文章"></a>技术文章</h2><ul><li><a href="http://github.com/lizhe960118" target="_blank" rel="noopener">斯坦福课程cs231n</a></li></ul><hr><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢您花时间阅读我的简历，期待能有机会和您共事。</p>]]></content>
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
